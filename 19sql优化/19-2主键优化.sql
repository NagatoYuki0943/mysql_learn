在上一小节，我们提到，主键顺序插入的性能是要高于乱序插入的。 这一小节，就来介绍一下具体的
原因，然后再分析一下主键又该如何设计。
    1). 数据组织方式
        在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table IOT)。

        行数据，都是存储在聚集索引的叶子节点上的。而我们之前也讲解过InnoDB的逻辑结构图：

        在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。
        那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储
        到下一个页中，页与页之间会通过指针连接。


    2). 页分裂
        页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行
        溢出)，根据主键排列。

        A. 主键顺序插入效果
            ①. 从磁盘中申请页， 主键顺序插入

            ②. 第一个页没有满，继续往第一页插入

            ③. 当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接

            ④. 当第二页写满了，再往第三页写入

        B. 主键乱序插入效果
            ①. 加入 1#,2# 页都已经写满了，存放了如图所示的数

            ②. 此时再插入id为50的记录，我们来看看会发生什么现象
                会再次开启一个页，写入新的页中吗？

                不会。因为，索引结构的叶子节点是有顺序的。按照顺序，应该存储在47之后。

                但是47所在的1#页，已经写满了，存储不了50对应的数据了。 那么此时会开辟一个新的页 3#。

                但是并不会直接将50存入3#页，而是会将1#页后一半的数据，移动到3#页，然后在3#页，插入50。

                移动数据，并插入id为50的数据之后，那么此时，这三个页之间的数据顺序是有问题的。 1#的下一个
                页，应该是3#， 3#的下一个页是2#。 所以，此时，需要重新设置链表指针。

                上述的这种现象，称之为 "页分裂"，是比较耗费性能的操作。

    3). 页合并
        目前表中已有数据的索引结构(叶子节点)如下：

        当我们对已有数据进行删除时，具体的效果如下:
        当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间
        变得允许被其他记录声明使用。

        当我们继续删除2#的数据记录

        当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前
        或后）看看是否可以将两个页合并以优化空间使用。

        删除数据，并将页合并之后，再次插入新的数据21，则直接插入3#页

    这个里面所发生的合并页的这个现象，就称之为 "页合并"。

    4). 索引设计原则
        - 满足业务需求的情况下，尽量降低主键的长度。
        - 插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。
        - 尽量不要使用UUID做主键或者是其他自然主键，如身份证号。
        - 业务操作时，避免对主键的修改。



