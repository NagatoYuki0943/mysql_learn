1 验证索引效率
    在讲解索引的使用原则之前，先通过一个简单的案例，来验证一下索引，看看是否能够通过索引来提升
    数据查询性能。在演示的时候，我们还是使用之前准备的一张表 tb_sku , 在这张表中准备了1000w
    的记录。

    这张表中id为主键，有主键索引，而其他字段是没有建立索引的。 我们先来查询其中的一条记录，看
    看里面的字段情况，执行如下SQL：
        select * from tb_sku where id = 1\G;

    可以看到即使有1000w的数据,根据id进行数据查询,性能依然很快，因为主键id是有索引的。 那么接
    下来，我们再来根据 sn 字段进行查询，执行如下SQL：
        SELECT * FROM tb_sku WHERE sn = '100000003145001';

    我们可以看到根据sn字段进行查询，查询返回了一条数据，结果耗时 20.78sec，就是因为sn没有索
    引，而造成查询效率很低。
    那么我们可以针对于sn字段，建立一个索引，建立了索引之后，我们再次根据sn进行查询，再来看一
    下查询耗时情况。

    创建索引：
        create index idx_sku_sn on tb_sku(sn) ;

    然后再次执行相同的SQL语句，再次查看SQL的耗时。
        SELECT * FROM tb_sku WHERE sn = '100000003145001';

    我们明显会看到，sn字段建立了索引之后，查询性能大大提升。建立索引前后，查询耗时都不是一个数量级的。


2 最左前缀法则
    如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，
    并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。
    以 m_tb_user 表为例，我们先来查看一下之前 m_tb_user 表所创建的索引。

    在 m_tb_user 表中，有一个联合索引，这个联合索引涉及到三个字段，顺序分别为：profession， age，status。

    对于最左前缀法则指的是，查询时，最左变的列，也就是profession必须存在，否则索引全部失效。
    而且中间不能跳过某一列，否则该列后面的字段索引将失效。 接下来，我们来演示几组案例，看一下
    具体的执行计划：
        explain select * from m_tb_user where profession = '软件工程' and age = 31 and status = '0';
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------+
        | id | select_type | table     | partitions | type | possible_keys        | key                  | key_len | ref               | rows | filtered | Extra |
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------+
        |  1 | SIMPLE      | m_tb_user | NULL       | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 54      | const,const,const |    1 |   100.00 | NULL  |
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------+

        explain select * from m_tb_user where profession = '软件工程' and age = 31;
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------+------+----------+-------+
        | id | select_type | table     | partitions | type | possible_keys        | key                  | key_len | ref         | rows | filtered | Extra |
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------+------+----------+-------+
        |  1 | SIMPLE      | m_tb_user | NULL       | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 49      | const,const |    1 |   100.00 | NULL  |
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------+------+----------+-------+

        explain select * from m_tb_user where profession = '软件工程';
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------+------+----------+-------+
        | id | select_type | table     | partitions | type | possible_keys        | key                  | key_len | ref   | rows | filtered | Extra |
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------+------+----------+-------+
        |  1 | SIMPLE      | m_tb_user | NULL       | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 47      | const |    4 |   100.00 | NULL  |
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------+------+----------+-------+


    以上的这三组测试中，我们发现只要联合索引最左边的字段 profession存在，索引就会生效，只不
    过索引的长度不同。 而且由以上三组测试，我们也可以推测出profession字段索引长度为47、age
    字段索引长度为2、status字段索引长度为5。

        --最左边的索引列没有,索引就全失效了
        explain select * from m_tb_user where age = 31 and status = '0';
        +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+
        | id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
        +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+
        |  1 | SIMPLE      | m_tb_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   24 |     4.17 | Using where |
        +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+

        --最左边的索引列没有,索引就全失效了
        explain select * from m_tb_user where status = '0';
        +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+
        | id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
        +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+
        |  1 | SIMPLE      | m_tb_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   24 |    10.00 | Using where |
        +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+

    而通过上面的这两组测试，我们也可以看到索引并未生效，原因是因为不满足最左前缀法则，联合索引
    最左边的列profession不存在。


        --最左边的的列存在,跳过了age列,索引部分生效(status失效了)
        explain select * from m_tb_user where profession = '软件工程' and status = '0';
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------+------+----------+-----------------------+
        | id | select_type | table     | partitions | type | possible_keys        | key                  | key_len | ref   | rows | filtered | Extra                 |
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------+------+----------+-----------------------+
        |  1 | SIMPLE      | m_tb_user | NULL       | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 47      | const |    4 |    10.00 | Using index condition |
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------+------+----------+-----------------------+

    上述的SQL查询时，存在profession字段，最左边的列是存在的，索引满足最左前缀法则的基本条
    件。但是查询时，跳过了age这个列，所以后面的列索引是不会使用的，也就是索引部分生效，所以索
    引的长度就是47。


    思考题：
        当执行SQL语句: explain select * from m_tb_user where age = 31 and
        status = '0' and profession = '软件工程'； 时，是否满足最左前缀法则，走不走
        上述的联合索引，索引长度？
    可以看到，是完全满足最左前缀法则的，索引长度54，联合索引是生效的。

    注意 ： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是
    第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。


3 范围查询
    联合索引中，出现范围查询(>,<)，范围查询右侧的列索引失效。
        explain select * from m_tb_user where profession = '软件工程' and age > 30 and status = '0';
        +----+-------------+-----------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+
        | id | select_type | table     | partitions | type  | possible_keys        | key                  | key_len | ref  | rows | filtered | Extra                 |
        +----+-------------+-----------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+
        |  1 | SIMPLE      | m_tb_user | NULL       | range | idx_user_pro_age_sta | idx_user_pro_age_sta | 49      | NULL |    2 |    10.00 | Using index condition |
        +----+-------------+-----------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+

    当范围查询使用 > 或 < 时，走联合索引了，但是索引的长度为49，就说明范围查询右边的status字
    段是没有走索引的。


        explain select * from m_tb_user where profession = '软件工程' and age >= 30 and status = '0';
        +----+-------------+-----------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+
        | id | select_type | table     | partitions | type  | possible_keys        | key                  | key_len | ref  | rows | filtered | Extra                 |
        +----+-------------+-----------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+
        |  1 | SIMPLE      | m_tb_user | NULL       | range | idx_user_pro_age_sta | idx_user_pro_age_sta | 54      | NULL |    2 |    10.00 | Using index condition |
        +----+-------------+-----------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+

    当范围查询使用>= 或 <= 时，走联合索引了，但是索引的长度为54，就说明所有的字段都是走索引的。
    所以，在业务允许的情况下，尽可能的使用类似于 >= 或 <= 这类的范围查询，而避免使用 > 或 <。


4 索引失效情况

    1) 索引列运算,索引失效
        不要在索引列上进行运算操作， 索引将失效。
        在m_tb_user表中，除了前面介绍的联合索引之外，还有一个索引，是phone字段的单列索引。

        A. 当根据phone字段进行等值匹配查询时, 索引生效。
            explain select * from m_tb_user where phone = '17799990015';
            +----+-------------+-----------+------------+-------+----------------------+----------------+---------+-------+------+----------+-------+
            | id | select_type | table     | partitions | type  | possible_keys        | key            | key_len | ref   | rows | filtered | Extra |
            +----+-------------+-----------+------------+-------+----------------------+----------------+---------+-------+------+----------+-------+
            |  1 | SIMPLE      | m_tb_user | NULL       | const | idx_user_phone,phone | idx_user_phone | 46      | const |    1 |   100.00 | NULL  |
            +----+-------------+-----------+------------+-------+----------------------+----------------+---------+-------+------+----------+-------+

        B. 当根据phone字段进行函数运算操作之后，索引失效。
            explain select * from m_tb_user where substring(phone,10,2) = '15';--没使用key
            +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+
            | id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
            +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+
            |  1 | SIMPLE      | m_tb_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   24 |   100.00 | Using where |
            +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+


    2) 字符串不加引号,索引失效
        字符串类型字段使用时，不加引号，索引将失效。
        接下来，我们通过两组示例，来看看对于字符串类型的字段，加单引号与不加单引号的区别：

            explain select * from m_tb_user where profession = '软件工程' and age = 31 and status = '0';
            +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------+
            | id | select_type | table     | partitions | type | possible_keys        | key                  | key_len | ref               | rows | filtered | Extra |
            +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------+
            |  1 | SIMPLE      | m_tb_user | NULL       | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 54      | const,const,const |    1 |   100.00 | NULL  |
            +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------+

            explain select * from m_tb_user where profession = '软件工程' and age = 31 and status = 0;       --没用到最后的status
            +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------+------+----------+-----------------------+
            | id | select_type | table     | partitions | type | possible_keys        | key                  | key_len | ref         | rows | filtered | Extra                 |
            +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------+------+----------+-----------------------+
            |  1 | SIMPLE      | m_tb_user | NULL       | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 49      | const,const |    1 |    10.00 | Using index condition |
            +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------+------+----------+-----------------------+


            explain select * from m_tb_user where phone = '17799990015';
            +----+-------------+-----------+------------+-------+----------------------+----------------+---------+-------+------+----------+-------+
            | id | select_type | table     | partitions | type  | possible_keys        | key            | key_len | ref   | rows | filtered | Extra |
            +----+-------------+-----------+------------+-------+----------------------+----------------+---------+-------+------+----------+-------+
            |  1 | SIMPLE      | m_tb_user | NULL       | const | idx_user_phone,phone | idx_user_phone | 46      | const |    1 |   100.00 | NULL  |
            +----+-------------+-----------+------------+-------+----------------------+----------------+---------+-------+------+----------+-------+

            explain select * from m_tb_user where phone = 17799990015;                 --没用到key
            +----+-------------+-----------+------------+------+----------------------+------+---------+------+------+----------+-------------+
            | id | select_type | table     | partitions | type | possible_keys        | key  | key_len | ref  | rows | filtered | Extra       |
            +----+-------------+-----------+------------+------+----------------------+------+---------+------+------+----------+-------------+
            |  1 | SIMPLE      | m_tb_user | NULL       | ALL  | idx_user_phone,phone | NULL | NULL    | NULL |   24 |    10.00 | Using where |
            +----+-------------+-----------+------------+------+----------------------+------+---------+------+------+----------+-------------+

        经过上面两组示例，我们会明显的发现，如果字符串不加单引号，对于查询结果，没什么影响，但是数
        据库存在隐式类型转换，索引将失效。


    3) 模糊查询
        如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。
        接下来，我们来看一下这三条SQL语句的执行效果，查看一下其执行计划：
        由于下面查询语句中，都是根据profession字段查询，符合最左前缀法则，联合索引是可以生效的，
        我们主要看一下，模糊查询时，%加在关键字之前，和加在关键字之后的影响。

            explain select * from m_tb_user where profession like '软件%';      --后面模糊查询索引生效
            +----+-------------+-----------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+
            | id | select_type | table     | partitions | type  | possible_keys        | key                  | key_len | ref  | rows | filtered | Extra                 |
            +----+-------------+-----------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+
            |  1 | SIMPLE      | m_tb_user | NULL       | range | idx_user_pro_age_sta | idx_user_pro_age_sta | 47      | NULL |    4 |   100.00 | Using index condition |
            +----+-------------+-----------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+

            explain select * from m_tb_user where profession like '%工程';      --前面模糊查询索引失效
            +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+
            | id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
            +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+
            |  1 | SIMPLE      | m_tb_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   24 |    11.11 | Using where |
            +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+

            explain select * from m_tb_user where profession like '%工%';       --前面模糊查询索引失效
            +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+
            | id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
            +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+
            |  1 | SIMPLE      | m_tb_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   24 |    11.11 | Using where |
            +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+

        经过上述的测试，我们发现，在like模糊查询中，在关键字后面加%，索引可以生效。而如果在关键字
        前面加了%，索引将会失效。


    4) or连接条件
        用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会
        被用到。

            explain select * from m_tb_user where id = 10 or phone = '17799990017';     --or前后都有索引才会用到所有索引
            +----+-------------+-----------+------------+-------------+------------------------------+------------------------+---------+------+------+----------+--------------------------------------------------+
            | id | select_type | table     | partitions | type        | possible_keys                | key                    | key_len | ref  | rows | filtered | Extra                                            |
            +----+-------------+-----------+------------+-------------+------------------------------+------------------------+---------+------+------+----------+--------------------------------------------------+
            |  1 | SIMPLE      | m_tb_user | NULL       | index_merge | PRIMARY,idx_user_phone,phone | PRIMARY,idx_user_phone | 4,46    | NULL |    2 |   100.00 | Using union(PRIMARY,idx_user_phone); Using where |
            +----+-------------+-----------+------------+-------------+------------------------------+------------------------+---------+------+------+----------+--------------------------------------------------+

            explain select * from m_tb_user where id = 10 or age = 23;         --or后面没有索引最终什么索引都不用
            +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+
            | id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
            +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+
            |  1 | SIMPLE      | m_tb_user | NULL       | ALL  | PRIMARY       | NULL | NULL    | NULL |   24 |    13.75 | Using where |
            +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+

            explain select * from m_tb_user where phone = '17799990017' or age = 23;  --or后面没有索引最终什么索引都不用
            +----+-------------+-----------+------------+------+----------------------+------+---------+------+------+----------+-------------+
            | id | select_type | table     | partitions | type | possible_keys        | key  | key_len | ref  | rows | filtered | Extra       |
            +----+-------------+-----------+------------+------+----------------------+------+---------+------+------+----------+-------------+
            |  1 | SIMPLE      | m_tb_user | NULL       | ALL  | idx_user_phone,phone | NULL | NULL    | NULL |   24 |    19.00 | Using where |
            +----+-------------+-----------+------------+------+----------------------+------+---------+------+------+----------+-------------+

        由于age没有索引，所以即使id、phone有索引，索引也会失效。所以需要针对于age也要建立索引。

        然后，我们可以对age字段建立索引。

            create index idx_user_age on m_tb_user(age);
            explain select * from m_tb_user where id = 10 or phone = '17799990017';                  --添加age索引后就用到了
            +----+-------------+-----------+------------+-------------+------------------------------+------------------------+---------+------+------+----------+--------------------------------------------------+
            | id | select_type | table     | partitions | type        | possible_keys                | key                    | key_len | ref  | rows | filtered | Extra                                            |
            +----+-------------+-----------+------------+-------------+------------------------------+------------------------+---------+------+------+----------+--------------------------------------------------+
            |  1 | SIMPLE      | m_tb_user | NULL       | index_merge | PRIMARY,idx_user_phone,phone | PRIMARY,idx_user_phone | 4,46    | NULL |    2 |   100.00 | Using union(PRIMARY,idx_user_phone); Using where |
            +----+-------------+-----------+------------+-------------+------------------------------+------------------------+---------+------+------+----------+--------------------------------------------------+
            explain select * from m_tb_user where phone = '17799990017' or age = 23;
            +----+-------------+-----------+------------+-------------+-----------------------------------+-----------------------------+---------+------+------+----------+-------------------------------------------------------+
            | id | select_type | table     | partitions | type        | possible_keys                     | key                         | key_len | ref  | rows | filtered | Extra                                                 |
            +----+-------------+-----------+------------+-------------+-----------------------------------+-----------------------------+---------+------+------+----------+-------------------------------------------------------+
            |  1 | SIMPLE      | m_tb_user | NULL       | index_merge | idx_user_phone,phone,idx_user_age | idx_user_phone,idx_user_age | 46,2    | NULL |    3 |   100.00 | Using union(idx_user_phone,idx_user_age); Using where |
            +----+-------------+-----------+------------+-------------+-----------------------------------+-----------------------------+---------+------+------+----------+-------------------------------------------------------+

        建立了索引之后，我们再次执行上述的SQL语句，看看前后执行计划的变化。

        最终，我们发现，当or连接的条件，左右两侧字段都有索引时，索引才会生效。


    5) 数据分布影响
        如果MySQL评估使用索引比全表更慢，则不使用索引。

            explain select * from m_tb_user where phone >= '17799990005';             --没用到索引
            +----+-------------+-----------+------------+------+----------------------+------+---------+------+------+----------+-------------+
            | id | select_type | table     | partitions | type | possible_keys        | key  | key_len | ref  | rows | filtered | Extra       |
            +----+-------------+-----------+------------+------+----------------------+------+---------+------+------+----------+-------------+
            |  1 | SIMPLE      | m_tb_user | NULL       | ALL  | idx_user_phone,phone | NULL | NULL    | NULL |   24 |    79.17 | Using where |
            +----+-------------+-----------+------------+------+----------------------+------+---------+------+------+----------+-------------+

            explain select * from m_tb_user where phone >= '17799990015';
            +----+-------------+-----------+------------+-------+----------------------+----------------+---------+------+------+----------+-----------------------+
            | id | select_type | table     | partitions | type  | possible_keys        | key            | key_len | ref  | rows | filtered | Extra                 |
            +----+-------------+-----------+------------+-------+----------------------+----------------+---------+------+------+----------+-----------------------+
            |  1 | SIMPLE      | m_tb_user | NULL       | range | idx_user_phone,phone | idx_user_phone | 46      | NULL |    9 |   100.00 | Using index condition |
            +----+-------------+-----------+------------+-------+----------------------+----------------+---------+------+------+----------+-----------------------+

        经过测试我们发现，相同的SQL语句，只是传入的字段值不同，最终的执行计划也完全不一样，这是为
        什么呢？
        就是因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃
        索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不
        如走全表扫描来的快，此时索引就会失效。
        接下来，我们再来看看 is null 与 is not null 操作是否走索引。
        执行如下两条语句 ：

            explain select * from m_tb_user where profession is null;
            +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------+------+----------+-----------------------+
            | id | select_type | table     | partitions | type | possible_keys        | key                  | key_len | ref   | rows | filtered | Extra                 |
            +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------+------+----------+-----------------------+
            |  1 | SIMPLE      | m_tb_user | NULL       | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 47      | const |    1 |   100.00 | Using index condition |
            +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------+------+----------+-----------------------+

            explain select * from m_tb_user where profession is not null;            --没用到索引
            +----+-------------+-----------+------------+------+----------------------+------+---------+------+------+----------+-------------+
            | id | select_type | table     | partitions | type | possible_keys        | key  | key_len | ref  | rows | filtered | Extra       |
            +----+-------------+-----------+------------+------+----------------------+------+---------+------+------+----------+-------------+
            |  1 | SIMPLE      | m_tb_user | NULL       | ALL  | idx_user_pro_age_sta | NULL | NULL    | NULL |   24 |   100.00 | Using where |
            +----+-------------+-----------+------------+------+----------------------+------+---------+------+------+----------+-------------+

        接下来，我们做一个操作将profession字段值全部更新为null。
            update m_tb_user set profession = null;

        然后，再次执行上述的两条SQL，查看SQL语句的执行计划。

            explain select * from m_tb_user where profession is null;
            +----+-------------+-----------+------------+------+----------------------+------+---------+------+------+----------+-------------+
            | id | select_type | table     | partitions | type | possible_keys        | key  | key_len | ref  | rows | filtered | Extra       |
            +----+-------------+-----------+------------+------+----------------------+------+---------+------+------+----------+-------------+
            |  1 | SIMPLE      | m_tb_user | NULL       | ALL  | idx_user_pro_age_sta | NULL | NULL    | NULL |   24 |   100.00 | Using where |
            +----+-------------+-----------+------------+------+----------------------+------+---------+------+------+----------+-------------+

            explain select * from m_tb_user where profession is not null;
            +----+-------------+-----------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+
            | id | select_type | table     | partitions | type  | possible_keys        | key                  | key_len | ref  | rows | filtered | Extra                 |
            +----+-------------+-----------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+
            |  1 | SIMPLE      | m_tb_user | NULL       | range | idx_user_pro_age_sta | idx_user_pro_age_sta | 47      | NULL |    1 |   100.00 | Using index condition |
            +----+-------------+-----------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+

        最终我们看到，一模一样的SQL语句，先后执行了两次，结果查询计划是不一样的，为什么会出现这种
        现象，这是和数据库的数据分布有关系。查询时MySQL会评估，走索引快，还是全表扫描快，如果全表
        扫描更快，则放弃索引走全表扫描。 因此，is null 、is not null是否走索引，得具体情况具体
        分析，并不是固定的。


5 SQL提示(人为提示sql)   use/ignore/force index(index_name)
    恢复上面修改的数据,profession字段全设为null了
    目前m_tb_user表的数据情况如下:
        select * from m_tb_user;
        +----+--------+-------------+-----------------------+--------------------+-----+--------+--------+---------------------+
        | id | name   | phone       | email                 | profession         | age | gender | status | createtime          |
        +----+--------+-------------+-----------------------+--------------------+-----+--------+--------+---------------------+
        |  1 | 吕布   | 17799990000 | lvbu666@163.com       | 软件工程           |  23 | 1      | 6      | 2001-02-02 00:00:00 |
        |  2 | 曹操   | 17799990001 | caocao666@qq.com      | 通讯工程           |  33 | 1      | 0      | 2001-03-05 00:00:00 |
        |  3 | 赵云   | 17799990002 | 17799990@139.com      | 英语               |  34 | 1      | 2      | 2002-03-02 00:00:00 |
        |  4 | 孙悟空 | 17799990003 | 17799990@sina.com     | 工程造价           |  54 | 1      | 0      | 2001-07-02 00:00:00 |
        |  5 | 花木兰 | 17799990004 | 19980729@sina.com     | 软件工程           |  23 | 2      | 1      | 2001-04-22 00:00:00 |
        |  6 | 大乔   | 17799990005 | daqiao666@sina.com    | 舞蹈               |  22 | 2      | 0      | 2001-02-07 00:00:00 |
        |  7 | 露娜   | 17799990006 | luna_love@sina.com    | 应用数学           |  24 | 2      | 0      | 2001-02-08 00:00:00 |
        |  8 | 程咬金 | 17799990007 | chengyaojin@163.com   | 化工               |  38 | 1      | 5      | 2001-05-23 00:00:00 |
        |  9 | 项羽   | 17799990008 | xiaoyu666@qq.com      | 金属材料           |  43 | 1      | 0      | 2001-09-18 00:00:00 |
        | 10 | 白起   | 17799990009 | baiqi666@sina.com     | 机械工程及其自动化 |  27 | 1      | 2      | 2001-08-16 00:00:00 |
        | 11 | 韩信   | 17799990010 | hanxin520@163.com     | 无机非金属材料工程 |  27 | 1      | 0      | 2001-06-12 00:00:00 |
        | 12 | 荆轲   | 17799990011 | jingke123@163.com     | 会计               |  29 | 1      | 0      | 2001-05-11 00:00:00 |
        | 13 | 兰陵王 | 17799990012 | lanlinwang666@126.com | 工程造价           |  44 | 1      | 1      | 2001-04-09 00:00:00 |
        | 14 | 狂铁   | 17799990013 | kuangtie@sina.com     | 应用数学           |  43 | 1      | 2      | 2001-04-10 00:00:00 |
        | 15 | 貂蝉   | 17799990014 | 84958948374@qq.com    | 软件工程           |  40 | 2      | 3      | 2001-02-12 00:00:00 |
        | 16 | 妲己   | 17799990015 | 2783238293@qq.com     | 软件工程           |  31 | 2      | 0      | 2001-01-30 00:00:00 |
        | 17 | 芈月   | 17799990016 | xiaomin2001@sina.com  | 工业经济           |  35 | 2      | 0      | 2000-05-03 00:00:00 |
        | 18 | 嬴政   | 17799990017 | 8839434342@qq.com     | 化工               |  38 | 1      | 1      | 2001-08-08 00:00:00 |
        | 19 | 狄仁杰 | 17799990018 | jujiamlm8166@163.com  | 国际贸易           |  30 | 1      | 0      | 2007-03-12 00:00:00 |
        | 20 | 安琪拉 | 17799990019 | jdodm1h@126.com       | 城市规划           |  51 | 2      | 0      | 2001-08-15 00:00:00 |
        | 21 | 典韦   | 17799990020 | ycaunanjian@163.com   | 城市规划           |  52 | 1      | 2      | 2000-04-12 00:00:00 |
        | 22 | 廉颇   | 17799990021 | lianpo321@126.com     | 土木工程           |  19 | 1      | 3      | 2002-07-18 00:00:00 |
        | 23 | 后羿   | 17799990022 | altycj2000@139.com    | 城市园林           |  20 | 1      | 0      | 2002-03-10 00:00:00 |
        | 24 | 姜子牙 | 17799990023 | 37483844@qq.com       | 工程造价           |  29 | 1      | 4      | 2003-05-26 00:00:00 |
        +----+--------+-------------+-----------------------+--------------------+-----+--------+--------+---------------------+

    索引情况如下
        show index from m_tb_user;
        +-----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
        | Table     | Non_unique | Key_name             | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible |
        +-----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
        | m_tb_user |          0 | PRIMARY              |            1 | id          | A         |          24 | NULL     | NULL   |      | BTREE      |         |               | YES     |
        | m_tb_user |          0 | idx_user_phone       |            1 | phone       | A         |          24 | NULL     | NULL   |      | BTREE      |         |               | YES     |
        | m_tb_user |          1 | idx_user_name        |            1 | name        | A         |          24 | NULL     | NULL   |      | BTREE      |         |               | YES     |
        | m_tb_user |          1 | idx_user_pro_age_sta |            1 | profession  | A         |          16 | NULL     | NULL   | YES  | BTREE      |         |               | YES     |
        | m_tb_user |          1 | idx_user_pro_age_sta |            2 | age         | A         |          22 | NULL     | NULL   | YES  | BTREE      |         |               | YES     |
        | m_tb_user |          1 | idx_user_pro_age_sta |            3 | status      | A         |          24 | NULL     | NULL   | YES  | BTREE      |         |               | YES     |
        | m_tb_user |          1 | idx_email            |            1 | email       | A         |          24 | NULL     | NULL   | YES  | BTREE      |         |               | YES     |
        | m_tb_user |          1 | idx_user_age         |            1 | age         | A         |          19 | NULL     | NULL   | YES  | BTREE      |         |               | YES     |
        +-----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+

    把上述的 idx_user_age, idx_email 这两个之前测试使用过的索引直接删除。

        drop index idx_user_age on m_tb_user;
        drop index idx_email on m_tb_user;

    A. 执行SQL :
        explain select * from m_tb_user where profession = '软件工程';             --查询走了联合索引
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------+------+----------+-------+
        | id | select_type | table     | partitions | type | possible_keys        | key                  | key_len | ref   | rows | filtered | Extra |
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------+------+----------+-------+
        |  1 | SIMPLE      | m_tb_user | NULL       | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 47      | const |    4 |   100.00 | NULL  |
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------+------+----------+-------+

    B. 执行SQL，创建profession的单列索引：
        create index idx_user_pro on m_tb_user(profession);

    C. 创建单列索引后，再次执行A中的SQL语句，查看执行计划，看看到底走哪个索引。
        测试结果，我们可以看到，possible_keys中 idx_user_pro_age_sta,idx_user_pro 这两个
        索引都可能用到，最终MySQL选择了idx_user_pro_age_sta索引。这是MySQL自动选择的结果。
        explain select * from m_tb_user where profession = '软件工程';
        +----+-------------+-----------+------------+------+-----------------------------------+----------------------+---------+-------+------+----------+-------+
        | id | select_type | table     | partitions | type | possible_keys                     | key                  | key_len | ref   | rows | filtered | Extra |
        +----+-------------+-----------+------------+------+-----------------------------------+----------------------+---------+-------+------+----------+-------+
        |  1 | SIMPLE      | m_tb_user | NULL       | ref  | idx_user_pro_age_sta,idx_user_pro | idx_user_pro_age_sta | 47      | const |    4 |   100.00 | NULL  |
        +----+-------------+-----------+------------+------+-----------------------------------+----------------------+---------+-------+------+----------+-------+

    那么，我们能不能在查询的时候，自己来指定使用哪个索引呢？ 答案是肯定的，此时就可以借助于
    MySQL的SQL提示来完成。 接下来，介绍一下SQL提示。

    SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。

        1). use index(index_name)： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进行评估）。
            explain select * from m_tb_user use index(idx_user_pro) where profession = '软件工程';
            +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
            | id | select_type | table     | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra |
            +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
            |  1 | SIMPLE      | m_tb_user | NULL       | ref  | idx_user_pro  | idx_user_pro | 47      | const |    4 |   100.00 | NULL  |
            +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------+


        2). ignore index(index_name)： 忽略指定的索引。
            explain select * from m_tb_user ignore index(idx_user_pro) where profession = '软件工程';
            +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------+------+----------+-------+
            | id | select_type | table     | partitions | type | possible_keys        | key                  | key_len | ref   | rows | filtered | Extra |
            +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------+------+----------+-------+
            |  1 | SIMPLE      | m_tb_user | NULL       | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 47      | const |    4 |   100.00 | NULL  |
            +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------+------+----------+-------+

            explain select * from m_tb_user ignore index(idx_user_pro_age_sta) where profession = '软件工程';
            +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
            | id | select_type | table     | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra |
            +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
            |  1 | SIMPLE      | m_tb_user | NULL       | ref  | idx_user_pro  | idx_user_pro | 47      | const |    4 |   100.00 | NULL  |
            +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------+


        3). force index(index_name)： 强制使用索引。
            explain select * from m_tb_user force index(idx_user_pro) where profession = '软件工程';
            +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
            | id | select_type | table     | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra |
            +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
            |  1 | SIMPLE      | m_tb_user | NULL       | ref  | idx_user_pro  | idx_user_pro | 47      | const |    4 |   100.00 | NULL  |
            +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------+

            explain select * from m_tb_user force index(idx_user_pro_age_sta) where profession = '软件工程';
            +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------+------+----------+-------+
            | id | select_type | table     | partitions | type | possible_keys        | key                  | key_len | ref   | rows | filtered | Extra |
            +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------+------+----------+-------+
            |  1 | SIMPLE      | m_tb_user | NULL       | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 47      | const |    4 |   100.00 | NULL  |
            +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------+------+----------+-------+


6 覆盖索引(返回的列，在索引中全部能够找到)
    尽量使用覆盖索引，减少select *。 那么什么是覆盖索引呢？ 覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到。
        show index from m_tb_user;
        +-----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
        | Table     | Non_unique | Key_name             | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible |
        +-----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
        | m_tb_user |          0 | PRIMARY              |            1 | id          | A         |          24 | NULL     | NULL   |      | BTREE      |         |               | YES     |
        | m_tb_user |          0 | idx_user_phone       |            1 | phone       | A         |          24 | NULL     | NULL   |      | BTREE      |         |               | YES     |
        | m_tb_user |          1 | idx_user_name        |            1 | name        | A         |          24 | NULL     | NULL   |      | BTREE      |         |               | YES     |
        | m_tb_user |          1 | idx_user_pro_age_sta |            1 | profession  | A         |          16 | NULL     | NULL   | YES  | BTREE      |         |               | YES     |
        | m_tb_user |          1 | idx_user_pro_age_sta |            2 | age         | A         |          22 | NULL     | NULL   | YES  | BTREE      |         |               | YES     |
        | m_tb_user |          1 | idx_user_pro_age_sta |            3 | status      | A         |          24 | NULL     | NULL   | YES  | BTREE      |         |               | YES     |
        +-----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+

    接下来，我们来看一组SQL的执行计划，看看执行计划的差别，然后再来具体做一个解析。  看最后的extra

        --前2条执行计划没有变化   最后面的extra为 Using index
        explain select id,profession from m_tb_user where profession = '软件工程' and age = 31 and status = '0';
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------------+
        | id | select_type | table     | partitions | type | possible_keys        | key                  | key_len | ref               | rows | filtered | Extra       |
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------------+
        |  1 | SIMPLE      | m_tb_user | NULL       | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 54      | const,const,const |    1 |   100.00 | Using index |
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------------+

        --最后面的extra为 Using index
        explain select id,profession,age,status from m_tb_user where profession = '软件工程' and age = 31 and status = '0';
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------------+
        | id | select_type | table     | partitions | type | possible_keys        | key                  | key_len | ref               | rows | filtered | Extra       |
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------------+
        |  1 | SIMPLE      | m_tb_user | NULL       | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 54      | const,const,const |    1 |   100.00 | Using index |
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------------+

        --最后面的extra为null
        explain select id,profession,age,status,name from m_tb_user where profession = '软件工程' and age = 31 and status = '0';
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------+
        | id | select_type | table     | partitions | type | possible_keys        | key                  | key_len | ref               | rows | filtered | Extra |
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------+
        |  1 | SIMPLE      | m_tb_user | NULL       | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 54      | const,const,const |    1 |   100.00 | NULL  |
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------+

        --最后面的extra为null
        explain select * from m_tb_user where profession = '软件工程' and age = 31 and status = '0';
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------+
        | id | select_type | table     | partitions | type | possible_keys        | key                  | key_len | ref               | rows | filtered | Extra |
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------+
        |  1 | SIMPLE      | m_tb_user | NULL       | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 54      | const,const,const |    1 |   100.00 | NULL  |
        +----+-------------+-----------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------+

    从上述的执行计划我们可以看到，这四条SQL语句的执行计划前面所有的指标都是一样的，看不出来差
    异。但是此时，我们主要关注的是后面的Extra，前面两条SQL的结果为 Using where; Using
    Index ; 而后面两条SQL的结果为: Using index condition 。

        Extra                       含义
        Using where; Using Index    查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据
        Using index                 condition 查找使用了索引，但是需要回表查询数据


    因为，在m_tb_user表中有一个联合索引 idx_user_pro_age_sta，该索引关联了三个字段profession、age、status，
    而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主键id。 所以当我们查询返回的数据在 id、profession、
    age、status 之中，则直接走二级索引直接返回数据了。(存储的是id,所以和之前的索引就是需要的数据) 如果超出这个范围，
    就需要拿到主键id，再去扫描聚集索引，再获取额外的数据了，这个过程就是回表。
    而我们如果一直使用select * 查询返回所有字段值，很容易就会造成回表查询（除非是根据主键查询，此时只会扫描聚集索引）。

    为了大家更清楚的理解，什么是覆盖索引，什么是回表查询，我们一起再来看下面的这组SQL的执行过程。

    下面的ABCD请看PDF
    A. 表结构及索引示意图:
        id是主键，是一个聚集索引。 name字段建立了普通索引，是一个二级索引（辅助索引）。
    B. 执行SQL : select * from m_tb_user where id = 2;
        根据id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。
    C. 执行SQL：selet id,name from m_tb_user where name = 'Arm';
        虽然是根据name字段查询，查询二级索引，但是由于查询返回在字段为 id，name，在name的二级索
        引中，这两个值都是可以直接获取到的，因为覆盖索引，所以不需要回表查询，性能高。
    D. 执行SQL：selet id,name,gender from m_tb_user where name = 'Arm';
        由于在name的二级索引中，不包含gender，所以，需要两次索引扫描，也就是需要回表查询，性能相
        对较差一点。

    思考题：
    一张表, 有四个字段(id, username, password, status), 由于数据量大, 需要对
    以下SQL语句进行优化, 该如何进行才是最优方案:
    select id,username,password from m_tb_user where username ='itcast';

    答案: 针对于 username, password建立联合索引, sql为: create index
    idx_user_name_pass on m_tb_user(username,password);
    这样可以避免上述的SQL语句，在查询的过程中，出现回表查询


7 前缀索引
    当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让
    索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建
    立索引，这样可以大大节约索引空间，从而提高索引效率。

    1). 语法
        create index idx_xxxx on table_name(column(n)) ;

        示例:
        为m_tb_user表的email字段，建立长度为5的前缀索引。
        create index idx_email_5 on m_tb_user(email(5));

        show index from m_tb_user;
        +-----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
        | Table     | Non_unique | Key_name             | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible |
        +-----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
        | m_tb_user |          0 | PRIMARY              |            1 | id          | A         |          24 | NULL     | NULL   |      | BTREE      |         |               | YES     |
        | m_tb_user |          0 | idx_user_phone       |            1 | phone       | A         |          24 | NULL     | NULL   |      | BTREE      |         |               | YES     |
        | m_tb_user |          1 | idx_user_name        |            1 | name        | A         |          24 | NULL     | NULL   |      | BTREE      |         |               | YES     |
        | m_tb_user |          1 | idx_user_pro_age_sta |            1 | profession  | A         |          16 | NULL     | NULL   | YES  | BTREE      |         |               | YES     |
        | m_tb_user |          1 | idx_user_pro_age_sta |            2 | age         | A         |          22 | NULL     | NULL   | YES  | BTREE      |         |               | YES     |
        | m_tb_user |          1 | idx_user_pro_age_sta |            3 | status      | A         |          24 | NULL     | NULL   | YES  | BTREE      |         |               | YES     |
        | m_tb_user |          1 | idx_email_5          |            1 | email       | A         |          23 |        5 | NULL   | YES  | BTREE      |         |               | YES     |
        +-----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+

    2). 前缀长度
        可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，
        索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。
        select count(distinct email) / count(*) from m_tb_user; --email中不重复的数量
        +----------------------------------+
        | count(distinct email) / count(*) |
        +----------------------------------+
        | 1.0000                           |
        +----------------------------------+

        -- 一次截取前n的数据,这里发现前5个和前9个相同,所以选择5
        select count(distinct substring(email,1,5)) / count(*) from m_tb_user;
        +-------------------------------------------------+
        | count(distinct substring(email,1,5)) / count(*) |
        +-------------------------------------------------+
        | 0.9583                                          |
        +-------------------------------------------------+

        explain select * from m_tb_user where email='17799990@sina.com';   --用到了索引
        +----+-------------+-----------+------------+------+---------------+-------------+---------+-------+------+----------+-------------+
        | id | select_type | table     | partitions | type | possible_keys | key         | key_len | ref   | rows | filtered | Extra       |
        +----+-------------+-----------+------------+------+---------------+-------------+---------+-------+------+----------+-------------+
        |  1 | SIMPLE      | m_tb_user | NULL       | ref  | idx_email_5   | idx_email_5 | 23      | const |    2 |   100.00 | Using where |
        +----+-------------+-----------+------------+------+---------------+-------------+---------+-------+------+----------+-------------+

    3). 前缀索引的查询流程(看PDF)


8 单列索引与联合索引
    单列索引：即一个索引只包含单个列。
    联合索引：即一个索引包含了多个列。

    我们先来看看 m_tb_user 表中目前的索引情况:
        show index from m_tb_user;
        +-----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
        | Table     | Non_unique | Key_name             | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible |
        +-----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
        | m_tb_user |          0 | PRIMARY              |            1 | id          | A         |          24 | NULL     | NULL   |      | BTREE      |         |               | YES     |
        | m_tb_user |          0 | idx_user_phone       |            1 | phone       | A         |          24 | NULL     | NULL   |      | BTREE      |         |               | YES     |
        | m_tb_user |          1 | idx_user_name        |            1 | name        | A         |          24 | NULL     | NULL   |      | BTREE      |         |               | YES     |
        | m_tb_user |          1 | idx_user_pro_age_sta |            1 | profession  | A         |          16 | NULL     | NULL   | YES  | BTREE      |         |               | YES     |
        | m_tb_user |          1 | idx_user_pro_age_sta |            2 | age         | A         |          22 | NULL     | NULL   | YES  | BTREE      |         |               | YES     |
        | m_tb_user |          1 | idx_user_pro_age_sta |            3 | status      | A         |          24 | NULL     | NULL   | YES  | BTREE      |         |               | YES     |
        | m_tb_user |          1 | idx_email_5          |            1 | email       | A         |          23 |        5 | NULL   | YES  | BTREE      |         |               | YES     |
        +-----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+

    在查询出来的索引中，既有单列索引，又有联合索引。

    接下来，我们来执行一条SQL语句，看看其执行计划：
        explain select id,name,phone from m_tb_user where phone='17799990010' and name='韩信'; --只用了phone的索引,没用name的索引
        +----+-------------+-----------+------------+-------+------------------------------+----------------+---------+-------+------+----------+-------+
        | id | select_type | table     | partitions | type  | possible_keys                | key            | key_len | ref   | rows | filtered | Extra |
        +----+-------------+-----------+------------+-------+------------------------------+----------------+---------+-------+------+----------+-------+
        |  1 | SIMPLE      | m_tb_user | NULL       | const | idx_user_phone,idx_user_name | idx_user_phone | 46      | const |    1 |   100.00 | NULL  |
        +----+-------------+-----------+------------+-------+------------------------------+----------------+---------+-------+------+----------+-------+

    通过上述执行计划我们可以看出来，在and连接的两个字段 phone、name上都是有单列索引的，但是
    最终mysql只会选择一个索引，也就是说，只能走一个字段的索引，此时是会回表查询的(根据得到的id再回聚集索引中查找)。

    紧接着，我们再来创建一个phone和name字段的联合索引来查询一下执行计划。

        create unique index idx_user_phone_name on m_tb_user(phone,name);

    此时，查询时，就走了联合索引，而在联合索引中包含 phone、name的信息，在叶子节点下挂的是对应的主键id，所以查询是无需回表查询的。

        explain select id,name,phone from m_tb_user where phone='17799990010' and name='韩信';                 --使用了phone单列索引 extra中是NULL,使用了回表查询
        +----+-------------+-----------+------------+-------+--------------------------------------------------+----------------+---------+-------+------+----------+-------+
        | id | select_type | table     | partitions | type  | possible_keys                                    | key            | key_len | ref   | rows | filtered | Extra |
        +----+-------------+-----------+------------+-------+--------------------------------------------------+----------------+---------+-------+------+----------+-------+
        |  1 | SIMPLE      | m_tb_user | NULL       | const | idx_user_phone,idx_user_phone_name,idx_user_name | idx_user_phone | 46      | const |    1 |   100.00 | NULL  |
        +----+-------------+-----------+------------+-------+--------------------------------------------------+----------------+---------+-------+------+----------+-------+

        --use index(idx_user_phone_name) 建议使用联合索引, extra中是Using index,使用了覆盖索引
        explain select id,name,phone from m_tb_user use index(idx_user_phone_name) where phone='17799990010' and name='韩信';
        +----+-------------+-----------+------------+-------+---------------------+---------------------+---------+-------------+------+----------+-------------+
        | id | select_type | table     | partitions | type  | possible_keys       | key                 | key_len | ref         | rows | filtered | Extra       |
        +----+-------------+-----------+------------+-------+---------------------+---------------------+---------+-------------+------+----------+-------------+
        |  1 | SIMPLE      | m_tb_user | NULL       | const | idx_user_phone_name | idx_user_phone_name | 248     | const,const |    1 |   100.00 | Using index |
        +----+-------------+-----------+------------+-------+---------------------+---------------------+---------+-------------+------+----------+-------------+

    在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。

    注意前面的最左前缀法则,创建的索引是有顺序的,查询的时候条件必须有前面的索引才能用到后面的索引。

    如果查询使用的是联合索引，具体的结构示意图如下：(看PDF)
